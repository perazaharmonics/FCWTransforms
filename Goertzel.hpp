/*
 * *
 * * Filename: Goertzel.hpp
 * *
 * * Description:
 * *  Object-oriented Goertzel filter (single-bin DFT) for tone analysis.
 * *  Computes complex bin Y, magnitude, power, and phase for a target
 * *  frequency f0 over an input frame of length N. Stateless across calls.
 * *
 * *  Notes:
 * *   • Windowing is optional; pass taps generated by FCWTransforms.h.
 * *   • Readout uses standard formulation:
 * *       s[n]=x[n]+2cos(w)s[n-1]-s[n-2], 0<=n<N
 * *       Y=s[N-1]-e^{-jw}s[N-2],  w=2πf0/fs
 * *
 * *  Integration (FCWTransforms):
 * *   • Generate window taps in FCWTransforms (e.g., Hann, Blackman…)
 * *     and pass them to Analyze(...,window,wlen). Length must equal N.
 * *
 * *  Author:
 * *   JEP  J. Enrique Peraza
 */
#pragma once
#include <cstddef>
#include <cstdint>
#include <vector>
#include <cmath>
#include <limits>

namespace sig
{

template<typename T>
class Goertzel 
{
public:
    struct Params 
    {
      double fs=0.0;     // sample rate
      double f0=0.0;     // target frequency (Hz)
      std::size_t N=0;   // frame length
    };
    // Frequency bin components 
    struct Bin 
    {
        double re=0.0;
        double im=0.0;
        double magnitude=0.0;
        double power=0.0;
        double phase=0.0; // radians
    };

public:
    Goertzel(void){ }
    Goertzel(double fs,double f0,std::size_t N){ set(fs,f0,N); }

    // Set all parameters at once
    bool Init(double fs,double f0,std::size_t N)
    {
      if(fs<=0.0||f0<=0.0||N<2) return false;
      pa.fs=fs;
      pa.f0=f0;
      pa.N=N;
      UpdateDerived();
      return true;
    }

    // Individual setters (each validates the full configuration)
    bool SetFs(double fs){ return set(fs,pa.f0,pa.N); }
    bool SetF0(double f0){ return set(pa.fs,f0,pa.N); }
    bool SetN(std::size_t N){ return set(pa.fs,pa.f0,N); }

    Params Get(void) const { return pa; }

    // Analyze raw pointer frame. Optional window taps length must equal N.
    // Returns false on invalid args. On success, fills out with complex bin Y.
    bool Analyze(const T* x,std::size_t len,Bin& out,const double* window=nullptr,std::size_t wlen=0) const 
    {
        if(!Valid()||x==nullptr||len!=pa.N)
          return false;
        const bool win=(window!=nullptr);
        if(win&&wlen!=pa.N)
          return false;
        double s1=0.0;
        double s2=0.0;
        // recurrence
        for(std::size_t n=0;n<pa.N;n++)
        {
          double xn=win?double(x[n])*window[n]: double(x[n]);
          double s=xn+c2*s1-s2;
          s2=s1;
          s1=s;
        }
        // complex readout
        double re=s1-s2*cw;
        double im=s2*sw;
        double power=re*re+im*im;
        double magnitude=std::sqrt(power);
        double phase=std::atan2(im,re);
        out.re=re;
        out.im=im;
        out.magnitude=magnitude;
        out.power=power;
        out.phase=phase;
        return true;
    }
    // Analyze iterator range [first,last). Window taps via pointer (optional).
    template<class It>
    bool Analyze(It first,It last,Bin& out,const double* window=nullptr,std::size_t wlen=0) const 
    {
        if(!Valid())
          return false;
        if(std::size_t(std::distance(first,last))!=pa.N)
          return false;
        const bool win=(window!=nullptr);
        if(win&&wlen!=pa.N)
          return false;
        double s1=0.0;
        double s2=0.0;
        std::size_t i=0;
        for(It it=first;it!=last;++it,++i)
        {
          double xn=win? double(*it)*window[i]: double(*it);
          double s=xn+c2*s1-s2;
          s2=s1;
          s1=s;
        }
        double re=s1-s2*cw;
        double im=s2*sw;
        double power=re*re+im*im;
        double magnitude=std::sqrt(power);
        double phase=std::atan2(im,re);
        out.re=re;
        out.im=im;
        out.magnitude=magnitude;
        out.power=power;
        out.phase=phase;
        return true;
    }

    // Convenience: analyze multiple frames laid out as contiguous frames with hop hop.
    // Produces one Bin per frame. Window taps must have length N if provided.
    std::vector<Bin> AnalyzeFrames(const T* x,std::size_t total,std::size_t hop,const double* window=nullptr,std::size_t wlen=0) const 
    {
        std::vector<Bin> outv;
        if(!Valid()||x==nullptr||hop==0||total<pa.N)
          return outv;
        if(window!=nullptr&&wlen!=pa.N)
          return outv;
        std::size_t i0=0;
        while(i0+pa.N<=total)
        {
          Bin b{};
          Analyze(x+i0,pa.N,b,window,wlen);
          outv.push_back(b);
          i0+=hop;
        }
        return outv;
    }

    // Helpers: build from bin index k (0..N-1) or compute k from f0
    // Note: this uses exact w=2πk/N for pure DFT bin targeting.
    bool SetFromBin(std::size_t k,std::size_t N,double fs)
    {
        if(N<2||fs<=0.0||k>=N) return false;
        double f0=(double(k)/double(N))*fs;
        return set(fs,f0,N);
    }
    std::size_t BinIndex(void) const
    {
        if(!Valid()) return 0;
        double k=(pa.f0/pa.fs)*double(pa.N);
        if(k<0.0) k=0.0;
        return (std::size_t)(k+0.5);
    }

    // Optional: Quinn/Jacobsen fractional-bin refinement using neighboring Goertzels.
    // Returns refined frequency in Hz. If neighbors not provided, returns f0.
    bool RefineFrequency3Point(const T* x,std::size_t len,double& fref,const double* window=nullptr,std::size_t wlen=0) const 
    {
        if(!Valid()||x==nullptr||len!=pa.N) return false;
        // compute bins at k-1, k, k+1 via temporary objects
        std::size_t k0=BinIndex();
        if(k0==0||k0+1>=pa.N){ fref=pa.f0; return true; }

        Goertzel<T> gm(*this),g0(*this),g0(*this);
        // set exact DFT-bin targets
        double fm=(double(k0-1)/double(pa.N))*pa.fs;
        double f0=(double(k0  )/double(pa.N))*pa.fs;
        double fp=(double(k0+1)/double(pa.N))*pa.fs;
        gm.set(pa.fs,fm,pa.N);
        g0.set(pa.fs,f0,pa.N);
        g0.set(pa.fs,fp,pa.N);

        Bin bm{},b0{},bp{};
        if(!gm.Analyze(x,len,bm,window,wlen)) return false;
        if(!g0.Analyze(x,len,b0,window,wlen)) return false;
        if(!g0.Analyze(x,len,bp,window,wlen)) return false;
        // Jacobsen 3-point estimator on complex bins
        // δ ≈ (Re{X[k+1]}-Re{X[k-1]})/(2*Re{X[k]}-Re{X[k+1]}-Re{X[k-1]})
        double num=(bp.re-bm.re);
        double den=(2.0*b0.re-bp.re-bm.re);
        double delta=(std::abs(den)<1e-30)? 0.0: num/den; // in bins
        double kref=double(k0)+delta;
        fref=(kref/double(pa.N))*pa.fs;
        return true;
    }

private:
    bool Valid (void) const {
        return pa.fs>0.0&&pa.f0>0.0&&pa.N>=2;
    }
    void UpdateDerived(void)
    {
      double w=2.0*M_PI*(pa.f0/pa.fs);
      c2=2.0*std::cos(w);
      cw=std::cos(w);
      sw=std::sin(w);
    }

private:
    Params pa;
    double c2=0.0;  // 2*cos(w)
    double cw=0.0;  // cos(w)
    double sw=0.0;  // sin(w)
};

} // namespace dsp
